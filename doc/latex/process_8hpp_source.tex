\hypertarget{process_8hpp_source}{\section{process.\+hpp}
\label{process_8hpp_source}\index{src/process.\+hpp@{src/process.\+hpp}}
}

\begin{DoxyCode}
00001 
00007 \textcolor{preprocessor}{#ifndef process\_H}
00008 \textcolor{preprocessor}{#define process\_H}
00009 
00010 \textcolor{preprocessor}{#include <map>}
00011 \textcolor{preprocessor}{#include <stdexcept>}
00012 
00013 \textcolor{preprocessor}{#include "\hyperlink{definitions_8hpp}{definitions.hpp}"}
00014 \textcolor{preprocessor}{#include "\hyperlink{sigmath_8hpp}{sigmath.hpp}"}
00015 
00016 \textcolor{keyword}{namespace }\hyperlink{namespacevaso}{vaso} \{    
\hypertarget{process_8hpp_source_l00054}{}\hyperlink{namespacevaso_a0a7aa548b31b50c92be5b08bcb1df9a0}{00054}     std::map<Side, DataParams> \hyperlink{namespacevaso_a0a7aa548b31b50c92be5b08bcb1df9a0}{Process}(\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}** data) \{
00055         \textcolor{comment}{// just in case SAMPLE\_COUNT isn't a power of two}
00056         \textcolor{keywordflow}{if}((\hyperlink{definitions_8hpp_a1682c770d91c5d167b621a782be940d4}{SAMPLE\_COUNT} & (\hyperlink{definitions_8hpp_a1682c770d91c5d167b621a782be940d4}{SAMPLE\_COUNT} - 1) != 0) || 
      \hyperlink{definitions_8hpp_a1682c770d91c5d167b621a782be940d4}{SAMPLE\_COUNT} < 2) \{
00057             \textcolor{keywordflow}{throw} std::invalid\_argument(
00058                     \textcolor{stringliteral}{"The number of samples is not a power of two!"});
00059         \}
00060 
00061         \textcolor{comment}{// declare function-scoped variables}
00062         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} freqSize = \hyperlink{definitions_8hpp_a1682c770d91c5d167b621a782be940d4}{SAMPLE\_COUNT} / 2;
00063         \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} cdata[\hyperlink{definitions_8hpp_aa44e6143be9e89f19be973956c22e134}{REC\_COUNT}][\hyperlink{definitions_8hpp_a1682c770d91c5d167b621a782be940d4}{SAMPLE\_COUNT}];
00064         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} fdata[\hyperlink{definitions_8hpp_aa44e6143be9e89f19be973956c22e134}{REC\_COUNT}][freqSize];
00065         \hyperlink{structDataParams}{DataParams} tempParams[\hyperlink{definitions_8hpp_aa44e6143be9e89f19be973956c22e134}{REC\_COUNT}];
00066         std::map<Side, DataParams> sideParams;
00067 
00068         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_adde6aaee8457bee49c2a92621fe22b79}{uint8} rCount = 0; rCount < \hyperlink{definitions_8hpp_aa44e6143be9e89f19be973956c22e134}{REC\_COUNT}; rCount++) \{
00069             \textcolor{comment}{// convert data to complex numbers for fft()}
00070             \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < \hyperlink{definitions_8hpp_a1682c770d91c5d167b621a782be940d4}{SAMPLE\_COUNT}; i++) \{
00071                 cdata[rCount][i] = data[rCount][i];
00072             \}
00073 
00074             \textcolor{comment}{// find frequency spectrum in relative decibels}
00075             \hyperlink{namespacevaso_af74f08a8afd7967b6c2b3c2b0e5fb1e9}{fft}(cdata[rCount], SAMPLE\_COUNT);
00076             \hyperlink{namespacevaso_a5d355b5c326a852e2ce95c258450898c}{mag}(cdata[rCount], fdata[rCount], freqSize);
00077             \hyperlink{structMaximum}{Maximum} maximum = \hyperlink{namespacevaso_a122846d728be312454a452d379915e10}{max}(fdata[rCount], freqSize);
00078 
00079             \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < freqSize; i++) \{
00080                 fdata[rCount][i] /= maximum.\hyperlink{structMaximum_aa7e84cbf37b694670142670014366969}{value};
00081             \}
00082 
00083             \hyperlink{namespacevaso_af9bb2211cf3478333dfc1873bf316263}{decibels}(fdata[rCount], freqSize);
00084 
00085             \textcolor{comment}{/*}
00086 \textcolor{comment}{             * Run spectrum values through moving-average filter to smooth the}
00087 \textcolor{comment}{             * curve and make it easier to determine the derivative.}
00088 \textcolor{comment}{             */}
00089             \hyperlink{namespacevaso_a5b7fc1a58199e2cac989f417a9faa1ce}{smooth}(fdata[rCount], freqSize, 20);
00090 
00091             \textcolor{comment}{/*}
00092 \textcolor{comment}{             * Find the derivative of the smoothed spectrum. Bote that both this}
00093 \textcolor{comment}{             * filter and the previous are necessary to the algorithm.}
00094 \textcolor{comment}{             */}
00095             \hyperlink{namespacevaso_a7d108bce812e906d8b1810815774c7ea}{diff}(fdata[rCount], freqSize);
00096             \hyperlink{namespacevaso_a5b7fc1a58199e2cac989f417a9faa1ce}{smooth}(fdata[rCount], freqSize, 100);
00097             \hyperlink{namespacevaso_a6ca90add966ce1773fc59a6883e6cd0c}{absolute}(fdata[rCount], freqSize);
00098 
00099             \textcolor{comment}{// find the parameters of this specific recording}
00100             \hyperlink{definitions_8hpp_a05f6b0ae8f6a6e135b0e290c25fe0e4e}{uint16} offset = 1000;
00101             \hyperlink{namespacevaso_a6ca90add966ce1773fc59a6883e6cd0c}{absolute}(&fdata[rCount][offset],    freqSize - offset);
00102             \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} index = \hyperlink{namespacevaso_a122846d728be312454a452d379915e10}{max}(&fdata[rCount][offset],
00103                     freqSize - offset).\hyperlink{structMaximum_a2e6aef03795cd285fe542d0861c6e3b5}{index};
00104             tempParams[rCount].\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} = index * (float)\hyperlink{definitions_8hpp_a9401e43a8c86acafb31c8e2709baefa1}{SAMPLE\_FREQ} / freqSize;
00105             tempParams[rCount].\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} =
00106                 \hyperlink{namespacevaso_ad3205136b1cd04b4c6b9d7be73661796}{average}(&fdata[rCount][index + 2 * offset],
00107                         freqSize - 2 * offset);
00108         \}
00109 
00110         \textcolor{comment}{// calculate the parameters for each side to be returned}
00111         sideParams[\hyperlink{namespacevaso_a77c5d9704657d49d456f691ddd8abf7ca945d5e233cf7d6240f6b783b36a374ff}{Side::Left}] = \hyperlink{namespacevaso_ad3205136b1cd04b4c6b9d7be73661796}{average}(&tempParams[0], REC\_COUNT / 2);
00112         sideParams[\hyperlink{namespacevaso_a77c5d9704657d49d456f691ddd8abf7ca92b09c7c48c520c3c55e497875da437c}{Side::Right}] = \hyperlink{namespacevaso_ad3205136b1cd04b4c6b9d7be73661796}{average}(&tempParams[REC\_COUNT / 2],
00113                 REC\_COUNT / 2);
00114         \textcolor{keywordflow}{return} sideParams;
00115     \}
00116 
\hypertarget{process_8hpp_source_l00117}{}\hyperlink{namespacevaso_a8136a2891983f7a41768330e018e3232}{00117}     \hyperlink{structDataParams}{DataParams} \hyperlink{namespacevaso_a8136a2891983f7a41768330e018e3232}{process}(\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}* data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size, 
      \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} samplingRate) \{
00118         \textcolor{comment}{// just in case SAMPLE\_COUNT isn't a power of two}
00119         \textcolor{keywordflow}{if}((size & (size - 1) != 0) || size < 2) \{
00120             \textcolor{keywordflow}{throw} std::invalid\_argument(
00121                     \textcolor{stringliteral}{"The number of samples is not a power of two!"});
00122         \}
00123 
00124         \textcolor{comment}{// declare function-scoped variables}
00125         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} freqSize = size / 2;
00126         \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}* cdata = (\hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}*)std::malloc(size * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}));
00127         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}* fdata = (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}*)std::malloc(freqSize * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}));
00128         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}* origdata = (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}*)std::malloc(freqSize * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}));
00129 
00130         \textcolor{comment}{// convert data to complex numbers for fft()}
00131         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00132             cdata[i] = data[i];
00133         \}
00134     
00135         \textcolor{comment}{// find frequency spectrum in relative decibels}
00136         \hyperlink{namespacevaso_af74f08a8afd7967b6c2b3c2b0e5fb1e9}{fft}(cdata, size);
00137         \hyperlink{namespacevaso_a5d355b5c326a852e2ce95c258450898c}{mag}(cdata, fdata, freqSize);
00138         \hyperlink{structMaximum}{Maximum} maximum = \hyperlink{namespacevaso_a122846d728be312454a452d379915e10}{max}(fdata, freqSize);
00139 
00140         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < freqSize; i++) \{
00141             fdata[i] /= maximum.\hyperlink{structMaximum_aa7e84cbf37b694670142670014366969}{value};
00142         \}
00143 
00144         \hyperlink{namespacevaso_af9bb2211cf3478333dfc1873bf316263}{decibels}(fdata, freqSize);
00145 
00146         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < freqSize; i++) \{
00147             origdata[i] = fdata[i];
00148         \}
00149 
00150         \textcolor{comment}{/*}
00151 \textcolor{comment}{         * Run spectrum values through moving-average filter to smooth the}
00152 \textcolor{comment}{         * curve and make it easier to determine the derivative.}
00153 \textcolor{comment}{         */}
00154         \hyperlink{namespacevaso_a5b7fc1a58199e2cac989f417a9faa1ce}{smooth}(fdata, freqSize, 20);
00155 
00156         \textcolor{comment}{/*}
00157 \textcolor{comment}{         * Find the derivative of the smoothed spectrum. Bote that both this}
00158 \textcolor{comment}{         * filter and the previous are necessary to the algorithm.}
00159 \textcolor{comment}{         */}
00160         \hyperlink{namespacevaso_a7d108bce812e906d8b1810815774c7ea}{diff}(fdata, freqSize);
00161         \hyperlink{namespacevaso_a5b7fc1a58199e2cac989f417a9faa1ce}{smooth}(fdata, freqSize, 100);
00162         \hyperlink{namespacevaso_a6ca90add966ce1773fc59a6883e6cd0c}{absolute}(fdata, freqSize);
00163 
00164         \textcolor{comment}{// find the parameters of this specific recording}
00165         \hyperlink{definitions_8hpp_a05f6b0ae8f6a6e135b0e290c25fe0e4e}{uint16} offset = 1000;
00166         \hyperlink{namespacevaso_a6ca90add966ce1773fc59a6883e6cd0c}{absolute}(&fdata[offset], freqSize - offset);
00167         maximum = \hyperlink{namespacevaso_a122846d728be312454a452d379915e10}{max}(&fdata[offset], freqSize - offset);
00168         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} index = maximum.\hyperlink{structMaximum_a2e6aef03795cd285fe542d0861c6e3b5}{index} + offset;
00169         \hyperlink{structDataParams}{DataParams} params;
00170         params.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} = index * (float)\hyperlink{definitions_8hpp_a9401e43a8c86acafb31c8e2709baefa1}{SAMPLE\_FREQ} / freqSize / 2;
00171         params.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} = \hyperlink{namespacevaso_ad3205136b1cd04b4c6b9d7be73661796}{average}(&origdata[index + offset],
00172                 freqSize - offset - index);
00173 
00174         free(cdata);
00175         free(fdata);
00176         \textcolor{keywordflow}{return} params;
00177 
00178     \}
00179 \}
00180 
00181 \textcolor{preprocessor}{#endif}
\end{DoxyCode}
