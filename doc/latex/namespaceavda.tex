\hypertarget{namespaceavda}{\section{avda Namespace Reference}
\label{namespaceavda}\index{avda@{avda}}
}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{Side} \{ \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a945d5e233cf7d6240f6b783b36a374ff}{Side\+::\+Left}, 
\hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a92b09c7c48c520c3c55e497875da437c}{Side\+::\+Right}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \hyperlink{namespaceavda_ae20728e7e8ae50bf2f74849e538841ea}{Patient\+Name} ()
\item 
std\+::map$<$ \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{Side}, \hyperlink{structDataParams}{Data\+Params} $>$ \hyperlink{namespaceavda_a46dc980b65ddfc24749ce25c1290e158}{Read\+Params} (auto filename)
\item 
void \hyperlink{namespaceavda_a1e3f5a0eb4ee9a7010d57dc38bd8dfec}{Write\+Params} (std\+::map$<$ \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{Side}, \hyperlink{structDataParams}{Data\+Params} $>$ params, auto filename)
\item 
\hyperlink{structDataParams}{Data\+Params} \hyperlink{namespaceavda_a5196cce27286d08ca144a460caee7839}{process} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size, \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} sampling\+Rate)
\item 
void \hyperlink{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}{absolute} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} \hyperlink{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61}{average} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
\hyperlink{structDataParams}{Data\+Params} \hyperlink{namespaceavda_a87927e04b25012fa7fa0fe05eefce41a}{average} (\hyperlink{structDataParams}{Data\+Params} $\ast$params, \hyperlink{definitions_8hpp_adde6aaee8457bee49c2a92621fe22b79}{uint8} size)
\item 
void \hyperlink{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5}{decibels} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
void \hyperlink{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce}{diff} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
void \hyperlink{namespaceavda_a33a1102422421212ac6b9387c896e864}{fft} (\hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
void \hyperlink{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee}{mag} (\hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} $\ast$orig, \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$newmags, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
\hyperlink{structMaximum}{Maximum} \hyperlink{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}{max} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
void \hyperlink{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}{smooth} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size, \hyperlink{definitions_8hpp_a05f6b0ae8f6a6e135b0e290c25fe0e4e}{uint16} order)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This namespace contains all code related to this project. 

\subsection{Enumeration Type Documentation}
\hypertarget{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{\index{avda@{avda}!Side@{Side}}
\index{Side@{Side}!avda@{avda}}
\subsubsection[{Side}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf avda\+::\+Side}\hspace{0.3cm}{\ttfamily [strong]}}}\label{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}
Side of the head to which a recording pertains. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{Left@{Left}!avda@{avda}}\index{avda@{avda}!Left@{Left}}\item[{\em 
\hypertarget{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a945d5e233cf7d6240f6b783b36a374ff}{Left}\label{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a945d5e233cf7d6240f6b783b36a374ff}
}]\index{Right@{Right}!avda@{avda}}\index{avda@{avda}!Right@{Right}}\item[{\em 
\hypertarget{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a92b09c7c48c520c3c55e497875da437c}{Right}\label{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a92b09c7c48c520c3c55e497875da437c}
}]\end{description}
\end{Desc}


Definition at line \hyperlink{definitions_8hpp_source_l00145}{145} of file \hyperlink{definitions_8hpp_source}{definitions.\+hpp}.


\begin{DoxyCode}
00145 \{ \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a945d5e233cf7d6240f6b783b36a374ff}{Left}, \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a92b09c7c48c520c3c55e497875da437c}{Right} \};
\end{DoxyCode}


\subsection{Function Documentation}
\hypertarget{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}{\index{avda@{avda}!absolute@{absolute}}
\index{absolute@{absolute}!avda@{avda}}
\subsubsection[{absolute}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::absolute (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}
Ensures all elements in an array are positive. Note that this function replaces array elements if necessary. It does not populate a new array.


\begin{DoxyParams}{Parameters}
{\em data} & array whose elements must all be positive\\
\hline
{\em size} & number of elements in the data array \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00123}{123} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00123                                               \{
00124         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00125             data[i] = fabsf(data[i]);
00126         \}
00127     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61}{\index{avda@{avda}!average@{average}}
\index{average@{average}!avda@{avda}}
\subsubsection[{average}]{\setlength{\rightskip}{0pt plus 5cm}{\bf float32} avda\+::average (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61}
Takes the average of all elements in an array


\begin{DoxyParams}{Parameters}
{\em data} & array from which to compute the average\\
\hline
{\em size} & number of elements in the data array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
computed average 
\end{DoxyReturn}


Definition at line \hyperlink{sigmath_8hpp_source_l00129}{129} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00129                                                 \{
00130         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} ave;
00131 
00132         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00133             ave += data[i];
00134         \}
00135 
00136         ave = ave / size;
00137         \textcolor{keywordflow}{return} ave;
00138     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=346pt]{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a87927e04b25012fa7fa0fe05eefce41a}{\index{avda@{avda}!average@{average}}
\index{average@{average}!avda@{avda}}
\subsubsection[{average}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Data\+Params} avda\+::average (
\begin{DoxyParamCaption}
\item[{{\bf Data\+Params} $\ast$}]{params, }
\item[{{\bf uint8}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a87927e04b25012fa7fa0fe05eefce41a}
Finds the averages of the elements of an array of \hyperlink{structDataParams}{Data\+Params}.


\begin{DoxyParams}{Parameters}
{\em params} & \hyperlink{structDataParams}{Data\+Params} array\\
\hline
{\em size} & number of elements in the \hyperlink{structDataParams}{Data\+Params} array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\hyperlink{structDataParams}{Data\+Params} structure containing the average values of the structure's elements in the params array 
\end{DoxyReturn}


Definition at line \hyperlink{sigmath_8hpp_source_l00140}{140} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00140                                                        \{
00141         \hyperlink{structDataParams}{DataParams} ave;
00142 
00143         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_adde6aaee8457bee49c2a92621fe22b79}{uint8} i = 0; i < size; i++) \{
00144             \textcolor{comment}{//freq is an attribute. this is how to add structure attributes}
00145             ave.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} += params[i].\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq};
00146             ave.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} += params[i].\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise};
00147         \}
00148 
00149         ave.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} /= size;
00150         ave.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} /= size;
00151         \textcolor{keywordflow}{return} ave;
00152     \}
\end{DoxyCode}
\hypertarget{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5}{\index{avda@{avda}!decibels@{decibels}}
\index{decibels@{decibels}!avda@{avda}}
\subsubsection[{decibels}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::decibels (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5}
Converts an array of floats to \char`\"{}power decibels\char`\"{}, i.\+e., x\mbox{[}n\mbox{]} = 20$\ast$log10(x\mbox{[}n\mbox{]}). The decibel values are written to the same array that contained the values to be converted. In other words, this function should perform an in-\/place, element-\/wise conversion.


\begin{DoxyParams}{Parameters}
{\em data} & array of values to be converted as well as the location where the converted values will be written\\
\hline
{\em size} & number of elements in the data array \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00154}{154} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00154                                               \{
00155         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00156             data[i] = 20 * log10(data[i]);
00157         \}
00158     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce}{\index{avda@{avda}!diff@{diff}}
\index{diff@{diff}!avda@{avda}}
\subsubsection[{diff}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::diff (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce}
Computes the left-\/handed first derivative of a discrete signal. The first element will be 0.


\begin{DoxyParams}{Parameters}
{\em data} & array containing the discrete signal data array\\
\hline
{\em size} & number of elements in data \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00160}{160} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00160                                           \{
00161         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} temp[size];
00162         temp[0] = 0;
00163 
00164         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 1; i < size; i++) \{
00165             temp[i] = data[i] - data[i-1];
00166         \}
00167 
00168         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00169             data[i] = temp[i];
00170         \}
00171     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=325pt]{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a33a1102422421212ac6b9387c896e864}{\index{avda@{avda}!fft@{fft}}
\index{fft@{fft}!avda@{avda}}
\subsubsection[{fft}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::fft (
\begin{DoxyParamCaption}
\item[{{\bf cfloat32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a33a1102422421212ac6b9387c896e864}
Replaces the values of an array of cfloat32's with the array's D\+F\+T using a decimation-\/in-\/frequency algorithm.

This code is based on code from \href{http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B}{\tt http\+://rosettacode.\+org/wiki/\+Fast\+\_\+\+Fourier\+\_\+transform\#\+C.\+2\+B.\+2\+B}.


\begin{DoxyParams}{Parameters}
{\em data} & array whose values should be replaced with its D\+F\+T\\
\hline
{\em size} & number of elements in the data array \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00173}{173} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00173                                           \{
00174         \textcolor{comment}{// DFT}
00175         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} k = size;
00176         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} n;
00177         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} thetaT = M\_PI / size;
00178         \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} phiT(cos(thetaT), sin(thetaT));
00179         \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} T;
00180 
00181         \textcolor{keywordflow}{while}(k > 1) \{
00182             n = k;
00183             k >>= 1;
00184             phiT = phiT * phiT;
00185             T = 1.0L;
00186 
00187             \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} l = 0; l < k; l++) \{
00188                 \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} a = l; a < size; a += n) \{
00189                     \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} b = a + k;
00190                     \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} t = data[a] - data[b];
00191                     data[a] += data[b];
00192                     data[b] = t * T;
00193                 \}
00194 
00195                 T *= phiT;
00196             \}
00197         \}
00198 
00199         \textcolor{comment}{// Decimate}
00200         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} m = (\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32})log2(size);
00201 
00202         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} a = 0; a < size; a++) \{
00203             \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} b = a;
00204 
00205             \textcolor{comment}{// Reverse bits}
00206             b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));
00207             b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));
00208             b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));
00209             b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));
00210             b = ((b >> 16) | (b << 16)) >> (32 - m);
00211 
00212             \textcolor{keywordflow}{if} (b > a)
00213             \{
00214                 \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} t = data[a];
00215                 data[a] = data[b];
00216                 data[b] = t;
00217             \}
00218         \}
00219     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=321pt]{namespaceavda_a33a1102422421212ac6b9387c896e864_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee}{\index{avda@{avda}!mag@{mag}}
\index{mag@{mag}!avda@{avda}}
\subsubsection[{mag}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::mag (
\begin{DoxyParamCaption}
\item[{{\bf cfloat32} $\ast$}]{orig, }
\item[{{\bf float32} $\ast$}]{newmags, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee}
Computes the magitude of an array of complex numbers.


\begin{DoxyParams}{Parameters}
{\em orig} & array of complex numbers\\
\hline
{\em newmags} & array to which the (real) magitudes are to be written\\
\hline
{\em size} & number of elements in orig and newmags \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00221}{221} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00221                                                             \{
00222         \textcolor{comment}{//loop to run throught the length of array orig}
00223         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} n = 0; n < size; n++) \{
00224             \textcolor{comment}{/* }
00225 \textcolor{comment}{             * abs should calculate the magnitude of complex array elements.}
00226 \textcolor{comment}{             * saves to new array}
00227 \textcolor{comment}{             */}
00228             newmags[n] = std::abs(orig[n]);     
00229         \}
00230     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}{\index{avda@{avda}!max@{max}}
\index{max@{max}!avda@{avda}}
\subsubsection[{max}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Maximum} avda\+::max (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}
Finds the maximum value in an array.


\begin{DoxyParams}{Parameters}
{\em data} & array whose maximum value is to be found\\
\hline
{\em size} & number of elements in the data array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
maximum value and its index 
\end{DoxyReturn}


Definition at line \hyperlink{sigmath_8hpp_source_l00232}{232} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00232                                             \{
00233         \hyperlink{structMaximum}{Maximum} m;
00234 
00235         \textcolor{comment}{//loop to run through the length of array data}
00236         \textcolor{keywordflow}{for} (\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00237             \textcolor{comment}{/* }
00238 \textcolor{comment}{             * when value at data[i] is above max.value,}
00239 \textcolor{comment}{             * sets max.value equal to data[i] and max.index equal to i}
00240 \textcolor{comment}{             */}
00241             \textcolor{keywordflow}{if} (data[i] > m.\hyperlink{structMaximum_aa7e84cbf37b694670142670014366969}{value}) \{
00242                 m.\hyperlink{structMaximum_aa7e84cbf37b694670142670014366969}{value} = data[i];
00243                 m.\hyperlink{structMaximum_a2e6aef03795cd285fe542d0861c6e3b5}{index} = i;
00244             \}
00245         \}
00246 
00247         \textcolor{keywordflow}{return} m;
00248     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_ae20728e7e8ae50bf2f74849e538841ea}{\index{avda@{avda}!Patient\+Name@{Patient\+Name}}
\index{Patient\+Name@{Patient\+Name}!avda@{avda}}
\subsubsection[{Patient\+Name}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string avda\+::\+Patient\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{namespaceavda_ae20728e7e8ae50bf2f74849e538841ea}
Prompts a user to enter a first, middle, and last name for a patient and creates a file (if necessary) in which all of the patient's data parameters can be saved. A newly created file will contain the C\+S\+V header for the file's data.

Must warn a user if the patient file does not already exist in order to prevent missaving data.

\begin{DoxyReturn}{Returns}
the file under which all patient data is saved 
\end{DoxyReturn}


Definition at line \hyperlink{fileio_8hpp_source_l00033}{33} of file \hyperlink{fileio_8hpp_source}{fileio.\+hpp}.


\begin{DoxyCode}
00033                             \{
00034         std::string fname = \textcolor{stringliteral}{""};
00035         std::string mname = \textcolor{stringliteral}{""};
00036         std::string lname = \textcolor{stringliteral}{""};
00037         std::string patfil = \textcolor{stringliteral}{""};
00038         std::string patientname = \textcolor{stringliteral}{""};
00039         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} track1 = 0;
00040         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} track2 = 0;
00041         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} track3 = 0;
00042 
00043         \textcolor{keywordflow}{do} \{
00044             std::cout << \textcolor{stringliteral}{"Please enter the patients name."} << std::endl;
00045             std::cout << \textcolor{stringliteral}{"First name: "};
00046             std::cin >> fname;
00047             std::cout << \textcolor{stringliteral}{"Middle name: "};
00048             std::cin >> mname;
00049             std::cout << \textcolor{stringliteral}{"Last name: "};
00050             std::cin >> lname;
00051 
00052             \textcolor{comment}{// creates new std::string with path to patient file}
00053             patientname = \hyperlink{definitions_8hpp_a5736990e7ea949fc1971afa00e421f16}{PATIENT\_PATH} + lname + \textcolor{stringliteral}{", "} + fname
00054                 + \textcolor{stringliteral}{" "} + mname + \textcolor{stringliteral}{".csv"};
00055 
00056             \textcolor{comment}{// prints out patientname. shows user the path to the patient file}
00057             \textcolor{comment}{//std::cout << patientname << std::endl << std::endl;}
00058             std::ifstream file(patientname.c\_str());
00059 
00060             \textcolor{keywordflow}{if} (file.good()) \{
00061                 track1 = 1;
00062             \}
00063 
00064             \textcolor{comment}{/*}
00065 \textcolor{comment}{             * Compares patientname to existing files and lets user know}
00066 \textcolor{comment}{             * if the file does not exist.}
00067 \textcolor{comment}{             */}
00068             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!file.good()) \{
00069                 \textcolor{comment}{/* }
00070 \textcolor{comment}{                 * Do while statement to continue asking user about the file}
00071 \textcolor{comment}{                 * if their input is not acceptable}
00072 \textcolor{comment}{                 */} 
00073                 \textcolor{keywordflow}{do} \{
00074                     std::cout << \textcolor{stringliteral}{"Patient file does not exist, would you like "}
00075                         \textcolor{stringliteral}{"to create file or re-enter their name?"} << std::endl;
00076                     std::cout << \textcolor{stringliteral}{"  *Type 'create' and press enter key "}
00077                         \textcolor{stringliteral}{"to create the patient file."} << std::endl;
00078                     std::cout << \textcolor{stringliteral}{"  *Type 'reenter' and press enter key "}
00079                         \textcolor{stringliteral}{"to re-enter the patients name."} << std::endl;
00080                     std::cout << std::endl;
00081                     std::cin >> patfil;
00082 
00083                     \textcolor{comment}{/* }
00084 \textcolor{comment}{                     * patfil equals create, track1 and 2 will increase}
00085 \textcolor{comment}{                     * escaping both do while loops}
00086 \textcolor{comment}{                     */}
00087                     \textcolor{keywordflow}{if}(patfil == \textcolor{stringliteral}{"create"}) \{
00088                         std::ofstream createfile(patientname.c\_str());
00089                         track1 = 1;
00090                         track2 = 1;
00091                         track3 = 1;
00092                         createfile << \hyperlink{definitions_8hpp_ac686b5c4edb9968dade15aad6e58bdca}{CSV\_HEADER} << std::endl;
00093                         createfile.flush();
00094                         createfile.close();
00095                     \}
00096 
00097                     \textcolor{comment}{/*}
00098 \textcolor{comment}{                     *patfil equals renter, track1 will remain zero allowing}
00099 \textcolor{comment}{                     *user to reenter the patient name.}
00100 \textcolor{comment}{                     */}
00101                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(patfil == \textcolor{stringliteral}{"reenter"}) \{
00102                         track1 = 0;
00103                         track2 = 1;
00104                     \}
00105 
00106                     \textcolor{comment}{/*}
00107 \textcolor{comment}{                     *The users input was neither create or reenter. User}
00108 \textcolor{comment}{                     *must enter patient name again.}
00109 \textcolor{comment}{                     */}
00110                     \textcolor{keywordflow}{else} \{
00111                         std::cout << std::endl;
00112                         std::cout << \textcolor{stringliteral}{"Your input is not acceptable."} << std::endl;
00113                         std::cout << std::endl;
00114                     \}
00115                 \}\textcolor{keywordflow}{while}(track2 == 0);
00116             \}
00117         \} \textcolor{keywordflow}{while} (track1 == 0);
00118 
00119         \textcolor{keywordflow}{return} patientname; \textcolor{comment}{//returns the path to the patient file}
00120     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{namespaceavda_ae20728e7e8ae50bf2f74849e538841ea_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a5196cce27286d08ca144a460caee7839}{\index{avda@{avda}!process@{process}}
\index{process@{process}!avda@{avda}}
\subsubsection[{process}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Data\+Params} avda\+::process (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size, }
\item[{{\bf float32}}]{sampling\+Rate}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a5196cce27286d08ca144a460caee7839}
Analyzes a single recording to determine the drop-\/off frequency and average noiseband noise power.

It should be noted that is algorithm is considered the intellectual property of Andrew Wisner and Nicholas Nolan. The \char`\"{}algorithm\char`\"{} is defined as the use of 1) the frequency drop-\/off and/or 2) a noise value from the frequency band above the drop-\/off frequency in order to diagnose (with or without other factors and parameters) the presence of a avdaspasm in a patient. By faculty members and/or students in the U\+A\+B E\+C\+E department using this algorithm, they agree that the presentation of their code or project that uses this algorithm, whether verbally or in writing, will reference the development of the initial algorithm by Andrew Wisner and Nicholas Nolan. Furthermore, a failure to meet this stipulation will warrant appropriate action by Andrew Wisner and/or Nicholas Nolan. It should be understood that the purpose of this stipulation is not to protect prioprietary rights; rather, it is to help ensure that the intellectual property of the algorithm's creators is protected and is neither misrepresented nor claimed implicitly or explicitly by another individual.


\begin{DoxyParams}{Parameters}
{\em data} & array containing float32 samples of audio\\
\hline
{\em size} & number of samples in each recording. M\+U\+S\+T be a power of two.\\
\hline
{\em sampling\+Rate} & sampling frequency in Hz or Samples/second\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cut-\/off frequency (Hz) and average noiseband noise power in decibels 
\end{DoxyReturn}


Definition at line \hyperlink{process_8hpp_source_l00048}{48} of file \hyperlink{process_8hpp_source}{process.\+hpp}.


\begin{DoxyCode}
00048                                                                          \{
00049         \textcolor{keywordflow}{if}((size & (size - 1) != 0) || size < 2) \{
00050             \textcolor{keywordflow}{throw} std::invalid\_argument(
00051                     \textcolor{stringliteral}{"The number of samples is not a power of two!"});
00052         \}
00053 
00054         \textcolor{comment}{// declare function-scoped variables}
00055         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} freqSize = size / 2;
00056         \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}* cdata = (\hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}*)std::malloc(size * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}));
00057         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}* fdata = (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}*)std::malloc(freqSize * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}));
00058         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}* origdata = (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}*)std::malloc(freqSize * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}));
00059 
00060         \textcolor{comment}{// convert data to complex numbers for fft()}
00061         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00062             cdata[i] = data[i];
00063         \}
00064     
00065         \textcolor{comment}{// find frequency spectrum in relative decibels}
00066         \hyperlink{namespaceavda_a33a1102422421212ac6b9387c896e864}{fft}(cdata, size);
00067         \hyperlink{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee}{mag}(cdata, fdata, freqSize);
00068         \hyperlink{structMaximum}{Maximum} maximum = \hyperlink{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}{max}(fdata, freqSize);
00069 
00070         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < freqSize; i++) \{
00071             fdata[i] /= maximum.\hyperlink{structMaximum_aa7e84cbf37b694670142670014366969}{value};
00072         \}
00073 
00074         \hyperlink{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5}{decibels}(fdata, freqSize);
00075 
00076         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < freqSize; i++) \{
00077             origdata[i] = fdata[i];
00078         \}
00079 
00080         \textcolor{comment}{/*}
00081 \textcolor{comment}{         * Run spectrum values through moving-average filter to smooth the}
00082 \textcolor{comment}{         * curve and make it easier to determine the derivative.}
00083 \textcolor{comment}{         */}
00084         \hyperlink{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}{smooth}(fdata, freqSize, 20);
00085 
00086         \textcolor{comment}{/*}
00087 \textcolor{comment}{         * Find the derivative of the smoothed spectrum. Bote that both this}
00088 \textcolor{comment}{         * filter and the previous are necessary to the algorithm.}
00089 \textcolor{comment}{         */}
00090         \hyperlink{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce}{diff}(fdata, freqSize);
00091         \hyperlink{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}{smooth}(fdata, freqSize, 100);
00092         \hyperlink{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}{absolute}(fdata, freqSize);
00093 
00094         \textcolor{comment}{// find the parameters of this specific recording}
00095         \hyperlink{definitions_8hpp_a05f6b0ae8f6a6e135b0e290c25fe0e4e}{uint16} offset = 1000;
00096         \hyperlink{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}{absolute}(&fdata[offset], freqSize - offset);
00097         maximum = \hyperlink{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}{max}(&fdata[offset], freqSize - offset);
00098         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} index = maximum.\hyperlink{structMaximum_a2e6aef03795cd285fe542d0861c6e3b5}{index} + offset;
00099         
00100         \hyperlink{structDataParams}{DataParams} params;
00101         params.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} = index * (float)\hyperlink{definitions_8hpp_a8ace559345ecba7978591ac2ef22aea4}{SAMPLE\_FREQ} / freqSize / 2;
00102         params.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} = \hyperlink{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61}{average}(&origdata[index + offset],
00103                 freqSize - offset - index);
00104 
00105         free(cdata);
00106         free(fdata);
00107 
00108         \textcolor{keywordflow}{return} params;
00109     \}
\end{DoxyCode}


Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=274pt]{namespaceavda_a5196cce27286d08ca144a460caee7839_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=232pt]{namespaceavda_a5196cce27286d08ca144a460caee7839_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a46dc980b65ddfc24749ce25c1290e158}{\index{avda@{avda}!Read\+Params@{Read\+Params}}
\index{Read\+Params@{Read\+Params}!avda@{avda}}
\subsubsection[{Read\+Params}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Side}, {\bf Data\+Params}$>$ avda\+::\+Read\+Params (
\begin{DoxyParamCaption}
\item[{auto}]{filename}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a46dc980b65ddfc24749ce25c1290e158}
Reads the previously computed parameters found in the specified file.


\begin{DoxyParams}{Parameters}
{\em filename} & absolute or relative path to the file containing the patient data to read\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
patient parameters read for each side 
\end{DoxyReturn}


Definition at line \hyperlink{fileio_8hpp_source_l00131}{131} of file \hyperlink{fileio_8hpp_source}{fileio.\+hpp}.


\begin{DoxyCode}
00131                                                        \{
00132         std::map<Side, DataParams> params;
00133         \hyperlink{structDataParams}{DataParams} leftparams;
00134         \hyperlink{structDataParams}{DataParams} rightparams;
00135 
00136         std::ifstream file(filename.c\_str());
00137         std::string leftline;
00138         std::string rightline;
00139         std::string leftsearch = \textcolor{stringliteral}{"Left"};
00140         std::string rightsearch = \textcolor{stringliteral}{"Right"};
00141         std::string paramstring;
00142         std::string lfreqstr;
00143         std::string lnoisestr;
00144         std::string rfreqstr;
00145         std::string rnoisestr;
00146         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} lcnt = 0;
00147         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} rcnt = 0;
00148         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} lfreqval;
00149         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} lnoiseval;
00150         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} rfreqval;
00151         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} rnoiseval;
00152 
00153         \textcolor{comment}{/*}
00154 \textcolor{comment}{         * if statement which uses ifstream function to open patient file }
00155 \textcolor{comment}{         * filename)}
00156 \textcolor{comment}{         */}
00157         \textcolor{keywordflow}{if}(file.is\_open()) \{
00158             \textcolor{comment}{/*}
00159 \textcolor{comment}{             * While statement to find the first Left line and save to }
00160 \textcolor{comment}{             *leftline as string.}
00161 \textcolor{comment}{             */}
00162             \textcolor{keywordflow}{while} (getline(file, leftline)) \{
00163                 \textcolor{keywordflow}{if}(leftline.find(leftsearch, 0) != std::string::npos) \{
00164                     \textcolor{keywordflow}{break};
00165                 \}
00166 
00167             \}
00168 
00169             \textcolor{comment}{/*}
00170 \textcolor{comment}{             * While statement to find first right line and save to rightline}
00171 \textcolor{comment}{             * as string.}
00172 \textcolor{comment}{             */}
00173             \textcolor{keywordflow}{while} (getline(file,rightline)) \{
00174                 \textcolor{keywordflow}{if}(rightline.find(rightsearch, 0) != std::string::npos) \{
00175                     \textcolor{keywordflow}{break};
00176                 \}
00177             \}
00178 
00179             \textcolor{comment}{// Code to break leftline and rightline into its parts}
00180             std::stringstream lss(leftline);
00181             std::stringstream rss(rightline);
00182 
00183             \textcolor{keywordflow}{while}(getline(lss,paramstring, \textcolor{charliteral}{','})) \{
00184                 lcnt++;
00185 
00186                 \textcolor{keywordflow}{if}(lcnt == 3) \{
00187                     lfreqstr = paramstring;
00188                 \}
00189 
00190                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(lcnt == 4) \{
00191                     lnoisestr = paramstring;
00192                 \}
00193             \}
00194 
00195             \textcolor{keywordflow}{while}(getline(rss,paramstring, \textcolor{charliteral}{','})) \{
00196                 rcnt++;
00197 
00198                 \textcolor{keywordflow}{if}(rcnt == 3) \{
00199                     rfreqstr = paramstring;
00200                 \}
00201 
00202                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(rcnt == 4) \{
00203                     rnoisestr = paramstring;
00204                 \}
00205             \}
00206 
00207             \textcolor{comment}{/*}
00208 \textcolor{comment}{             * Statement to convert lfreq, lnoise, rfreq, and rnoise from}
00209 \textcolor{comment}{             * strings to floats.}
00210 \textcolor{comment}{             * */}
00211             lfreqval = atof(lfreqstr.c\_str());
00212             lnoiseval = atof(lnoisestr.c\_str());
00213             rfreqval = atof(rfreqstr.c\_str());
00214             rnoiseval = atof(rnoisestr.c\_str());
00215 
00216             file.close();
00217         \}
00218 
00219         \textcolor{keywordflow}{else} \{
00220             \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"The patient file could not be opened."});
00221         \}
00222 
00223         leftparams.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} = lfreqval;
00224         leftparams.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} = lnoiseval;
00225         rightparams.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} = rfreqval;
00226         rightparams.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} = rnoiseval;
00227 
00228         params[Side::Left] = leftparams;
00229         params[Side::Right] = rightparams;
00230 
00231         \textcolor{keywordflow}{return} params;
00232     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{namespaceavda_a46dc980b65ddfc24749ce25c1290e158_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}{\index{avda@{avda}!smooth@{smooth}}
\index{smooth@{smooth}!avda@{avda}}
\subsubsection[{smooth}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::smooth (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size, }
\item[{{\bf uint16}}]{order}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}
Applies an nth-\/order moving-\/average filter to a discrete signal.


\begin{DoxyParams}{Parameters}
{\em data} & array containing the signal to which the filter should be applied\\
\hline
{\em size} & number of elements in the data array\\
\hline
{\em order} & order of the filter \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00250}{250} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00250                                                           \{
00251         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} coeff = 1 / (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32})order;
00252         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} temp[size];
00253 
00254         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00255             temp[i] = 0;
00256 
00257             \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a05f6b0ae8f6a6e135b0e290c25fe0e4e}{uint16} j = 0; j < order && j <= i; j++) \{
00258                 temp[i] += data[i - j];
00259             \}
00260 
00261             temp[i] *= coeff;
00262         \}
00263 
00264         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00265             data[i] = temp[i];
00266         \}
00267     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{namespaceavda_a22583ba7f11b69c955b13155bf9a739d_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a1e3f5a0eb4ee9a7010d57dc38bd8dfec}{\index{avda@{avda}!Write\+Params@{Write\+Params}}
\index{Write\+Params@{Write\+Params}!avda@{avda}}
\subsubsection[{Write\+Params}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::\+Write\+Params (
\begin{DoxyParamCaption}
\item[{std\+::map$<$ Side, {\bf Data\+Params} $>$}]{params, }
\item[{auto}]{filename}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a1e3f5a0eb4ee9a7010d57dc38bd8dfec}
Writes (appends) the passed parameters to the specified file.


\begin{DoxyParams}{Parameters}
{\em params} & parameters to be written\\
\hline
\end{DoxyParams}
the patient C\+S\+V file's filename 

Definition at line \hyperlink{fileio_8hpp_source_l00241}{241} of file \hyperlink{fileio_8hpp_source}{fileio.\+hpp}.


\begin{DoxyCode}
00241                                                                      \{
00242         \textcolor{keywordtype}{char} temp[80];
00243         std::ofstream file(filename.c\_str(),
00244                 std::ofstream::out | std::ofstream::app);
00245 
00246         \textcolor{comment}{//Gives pointer measurementtime a data type of time\_t.}
00247         time\_t measurementtime;
00248         time(&measurementtime); \textcolor{comment}{//Gets the current time.}
00249         strftime(temp, 80, \textcolor{stringliteral}{"%c"}, localtime(&measurementtime));
00250         std::string fTime = std::string(temp);
00251 
00252         \textcolor{comment}{//if statement to print the Left side parameters to the patient file.}
00253         \textcolor{keywordflow}{if}(file.is\_open()) \{
00254             file << fTime + \textcolor{stringliteral}{","} + \textcolor{stringliteral}{"Left"} + \textcolor{stringliteral}{","}
00255                 + std::to\_string(params[Side::Left].freq) 
00256                 + \textcolor{stringliteral}{", "} + std::to\_string(params[Side::Left].noise) << std::endl;
00257         \}
00258 
00259         \textcolor{comment}{//if statement to print the Right side parameters to the patient file.}
00260         \textcolor{keywordflow}{if}(file.is\_open()) \{
00261             file << fTime + \textcolor{stringliteral}{","} + \textcolor{stringliteral}{"Right"} + \textcolor{stringliteral}{","}
00262                 + std::to\_string(params[Side::Right].freq) 
00263                 + \textcolor{stringliteral}{", "} + std::to\_string(params[Side::Right].noise) << std::endl;
00264         \}
00265 
00266         \textcolor{keywordflow}{else} \{
00267             std::cout << \textcolor{stringliteral}{"Patient file can not be opened!"} << std::endl;
00268         \}
00269 
00270         file.close();
00271     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{namespaceavda_a1e3f5a0eb4ee9a7010d57dc38bd8dfec_icgraph}
\end{center}
\end{figure}


