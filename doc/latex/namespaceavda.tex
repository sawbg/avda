\hypertarget{namespaceavda}{\section{avda Namespace Reference}
\label{namespaceavda}\index{avda@{avda}}
}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{Side} \{ \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a945d5e233cf7d6240f6b783b36a374ff}{Side\+::\+Left}, 
\hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a92b09c7c48c520c3c55e497875da437c}{Side\+::\+Right}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string \hyperlink{namespaceavda_ae20728e7e8ae50bf2f74849e538841ea}{Patient\+Name} ()
\item 
std\+::map$<$ \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{Side}, \hyperlink{structDataParams}{Data\+Params} $>$ \hyperlink{namespaceavda_a46dc980b65ddfc24749ce25c1290e158}{Read\+Params} (auto filename)
\item 
void \hyperlink{namespaceavda_aba04a08b41833ced32ec803d55a63bee}{Write\+Params} (std\+::map$<$ \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{Side}, \hyperlink{structDataParams}{Data\+Params} $>$ my\+Map, auto filename)
\item 
\hyperlink{structDataParams}{Data\+Params} \hyperlink{namespaceavda_a5196cce27286d08ca144a460caee7839}{process} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size, \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} sampling\+Rate)
\item 
void \hyperlink{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}{absolute} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} \hyperlink{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61}{average} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
\hyperlink{structDataParams}{Data\+Params} \hyperlink{namespaceavda_a87927e04b25012fa7fa0fe05eefce41a}{average} (\hyperlink{structDataParams}{Data\+Params} $\ast$params, \hyperlink{definitions_8hpp_adde6aaee8457bee49c2a92621fe22b79}{uint8} size)
\item 
void \hyperlink{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5}{decibels} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
void \hyperlink{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce}{diff} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
void \hyperlink{namespaceavda_a33a1102422421212ac6b9387c896e864}{fft} (\hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
void \hyperlink{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee}{mag} (\hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} $\ast$orig, \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$newmags, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
\hyperlink{structMaximum}{Maximum} \hyperlink{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}{max} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size)
\item 
void \hyperlink{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}{smooth} (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} $\ast$data, \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} size, \hyperlink{definitions_8hpp_a05f6b0ae8f6a6e135b0e290c25fe0e4e}{uint16} order)
\item 
void \hyperlink{namespaceavda_a34f661f9a357bb68b0aa3662cc821e4d}{play} (auto filename)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const std\+::string \hyperlink{namespaceavda_ac568a0872c2c176d874b8b12f67f43ea}{C\+S\+V\+\_\+\+H\+E\+A\+D\+E\+R} = \char`\"{}Time,\hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{Side},Frequency,Noise Level\char`\"{}
\item 
const std\+::string \hyperlink{namespaceavda_a8ee73ec0cb55d4a13e89949764dce89d}{P\+A\+T\+I\+E\+N\+T\+\_\+\+P\+A\+T\+H} = \char`\"{}/home/pi/patients/\char`\"{}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This namespace contains all code related to this project. 

\subsection{Enumeration Type Documentation}
\hypertarget{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}{\index{avda@{avda}!Side@{Side}}
\index{Side@{Side}!avda@{avda}}
\subsubsection[{Side}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf avda\+::\+Side}\hspace{0.3cm}{\ttfamily [strong]}}}\label{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786}
Side of the head to which a recording pertains. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{Left@{Left}!avda@{avda}}\index{avda@{avda}!Left@{Left}}\item[{\em 
\hypertarget{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a945d5e233cf7d6240f6b783b36a374ff}{Left}\label{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a945d5e233cf7d6240f6b783b36a374ff}
}]\index{Right@{Right}!avda@{avda}}\index{avda@{avda}!Right@{Right}}\item[{\em 
\hypertarget{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a92b09c7c48c520c3c55e497875da437c}{Right}\label{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a92b09c7c48c520c3c55e497875da437c}
}]\end{description}
\end{Desc}


Definition at line \hyperlink{definitions_8hpp_source_l00121}{121} of file \hyperlink{definitions_8hpp_source}{definitions.\+hpp}.


\begin{DoxyCode}
00121 \{ \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a945d5e233cf7d6240f6b783b36a374ff}{Left}, \hyperlink{namespaceavda_af723e82f0d3d45fda6fdc01f6a492786a92b09c7c48c520c3c55e497875da437c}{Right} \};
\end{DoxyCode}


\subsection{Function Documentation}
\hypertarget{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}{\index{avda@{avda}!absolute@{absolute}}
\index{absolute@{absolute}!avda@{avda}}
\subsubsection[{absolute}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::absolute (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}
Ensures all elements in an array are positive. Note that this function replaces array elements if necessary. It does not populate a new array.


\begin{DoxyParams}{Parameters}
{\em data} & the array whose elements must all be positive\\
\hline
{\em size} & the number of elements in the data array \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00123}{123} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00123                                               \{
00124         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00125             data[i] = fabsf(data[i]);
00126         \}
00127     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61}{\index{avda@{avda}!average@{average}}
\index{average@{average}!avda@{avda}}
\subsubsection[{average}]{\setlength{\rightskip}{0pt plus 5cm}{\bf float32} avda\+::average (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61}
Takes the average of all elements in an array


\begin{DoxyParams}{Parameters}
{\em data} & the array from which to compute the average\\
\hline
{\em size} & the number of elements in the data array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the computed average 
\end{DoxyReturn}


Definition at line \hyperlink{sigmath_8hpp_source_l00129}{129} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00129                                                 \{
00130         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} ave;
00131 
00132         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00133             ave += data[i];
00134         \}
00135 
00136         ave = ave / size;
00137         \textcolor{keywordflow}{return} ave;
00138     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=346pt]{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a87927e04b25012fa7fa0fe05eefce41a}{\index{avda@{avda}!average@{average}}
\index{average@{average}!avda@{avda}}
\subsubsection[{average}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Data\+Params} avda\+::average (
\begin{DoxyParamCaption}
\item[{{\bf Data\+Params} $\ast$}]{params, }
\item[{{\bf uint8}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a87927e04b25012fa7fa0fe05eefce41a}
Finds the averages of the elements of an array of \hyperlink{structDataParams}{Data\+Params}.


\begin{DoxyParams}{Parameters}
{\em params} & the \hyperlink{structDataParams}{Data\+Params} array\\
\hline
{\em size} & the number of elements in the \hyperlink{structDataParams}{Data\+Params} array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \hyperlink{structDataParams}{Data\+Params} structure containing the average values of the structure's elements in the params array 
\end{DoxyReturn}


Definition at line \hyperlink{sigmath_8hpp_source_l00140}{140} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00140                                                        \{
00141         \hyperlink{structDataParams}{DataParams} ave;
00142 
00143         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_adde6aaee8457bee49c2a92621fe22b79}{uint8} i = 0; i < size; i++) \{
00144             \textcolor{comment}{//freq is an attribute. this is how to add structure attributes}
00145             ave.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} += params[i].\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq};
00146             ave.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} += params[i].\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise};
00147         \}
00148 
00149         ave.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} /= size;
00150         ave.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} /= size;
00151         \textcolor{keywordflow}{return} ave;
00152     \}
\end{DoxyCode}
\hypertarget{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5}{\index{avda@{avda}!decibels@{decibels}}
\index{decibels@{decibels}!avda@{avda}}
\subsubsection[{decibels}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::decibels (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5}
Converts an array of floats to \char`\"{}power decibels\char`\"{}, i.\+e., x\mbox{[}n\mbox{]} = 20$\ast$log10(x\mbox{[}n\mbox{]}). The decibel values are written to the same array that contained the values to be converted. In other words, this function should perform an in-\/place, element-\/wise conversion.


\begin{DoxyParams}{Parameters}
{\em data} & the array of values to be converted as well as the location where the converted values will be written\\
\hline
{\em size} & the number of elements in the data array \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00154}{154} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00154                                               \{
00155         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00156             data[i] = 20 * log10(data[i]);
00157         \}
00158     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=348pt]{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce}{\index{avda@{avda}!diff@{diff}}
\index{diff@{diff}!avda@{avda}}
\subsubsection[{diff}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::diff (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce}
Computes the left-\/handed first derivative of a discrete signal. The first element will be 0.


\begin{DoxyParams}{Parameters}
{\em data} & an array containing the discrete signal data\\
\hline
{\em size} & the number of elements in data \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00160}{160} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00160                                           \{
00161         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} temp[size];
00162         temp[0] = 0;
00163 
00164         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 1; i < size; i++) \{
00165             temp[i] = data[i] - data[i-1];
00166         \}
00167 
00168         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00169             data[i] = temp[i];
00170         \}
00171     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=325pt]{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a33a1102422421212ac6b9387c896e864}{\index{avda@{avda}!fft@{fft}}
\index{fft@{fft}!avda@{avda}}
\subsubsection[{fft}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::fft (
\begin{DoxyParamCaption}
\item[{{\bf cfloat32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a33a1102422421212ac6b9387c896e864}
Replaces the values of an array of cfloat32's with the array's D\+F\+T using a decimation-\/in-\/frequency algorithm.

This code is based on code from \href{http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B}{\tt http\+://rosettacode.\+org/wiki/\+Fast\+\_\+\+Fourier\+\_\+transform\#\+C.\+2\+B.\+2\+B}.


\begin{DoxyParams}{Parameters}
{\em data} & the array whose values should be replaced with its D\+F\+T\\
\hline
{\em size} & the number of elements in the data array \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00173}{173} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00173                                           \{
00174         \textcolor{comment}{// DFT}
00175         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} k = size;
00176         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} n;
00177         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} thetaT = M\_PI / size;
00178         \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} phiT(cos(thetaT), sin(thetaT));
00179         \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} T;
00180 
00181         \textcolor{keywordflow}{while}(k > 1) \{
00182             n = k;
00183             k >>= 1;
00184             phiT = phiT * phiT;
00185             T = 1.0L;
00186 
00187             \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} l = 0; l < k; l++) \{
00188                 \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} a = l; a < size; a += n) \{
00189                     \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} b = a + k;
00190                     \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} t = data[a] - data[b];
00191                     data[a] += data[b];
00192                     data[b] = t * T;
00193                 \}
00194 
00195                 T *= phiT;
00196             \}
00197         \}
00198 
00199         \textcolor{comment}{// Decimate}
00200         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} m = (\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32})log2(size);
00201 
00202         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} a = 0; a < size; a++) \{
00203             \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} b = a;
00204 
00205             \textcolor{comment}{// Reverse bits}
00206             b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));
00207             b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));
00208             b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));
00209             b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));
00210             b = ((b >> 16) | (b << 16)) >> (32 - m);
00211 
00212             \textcolor{keywordflow}{if} (b > a)
00213             \{
00214                 \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32} t = data[a];
00215                 data[a] = data[b];
00216                 data[b] = t;
00217             \}
00218         \}
00219     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=321pt]{namespaceavda_a33a1102422421212ac6b9387c896e864_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee}{\index{avda@{avda}!mag@{mag}}
\index{mag@{mag}!avda@{avda}}
\subsubsection[{mag}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::mag (
\begin{DoxyParamCaption}
\item[{{\bf cfloat32} $\ast$}]{orig, }
\item[{{\bf float32} $\ast$}]{newmags, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee}
Computes the magitude of an array of complex numbers.


\begin{DoxyParams}{Parameters}
{\em orig} & the array of complex numbers\\
\hline
{\em newmags} & an array to which the magitudes are to be written\\
\hline
{\em size} & the number of elements in orig and newmags \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00221}{221} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00221                                                             \{
00222         \textcolor{comment}{//loop to run throught the length of array orig}
00223         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} n = 0; n < size; n++) \{
00224             \textcolor{comment}{/* }
00225 \textcolor{comment}{             * abs should calculate the magnitude of complex array elements.}
00226 \textcolor{comment}{             * saves to new array}
00227 \textcolor{comment}{             */}
00228             newmags[n] = std::abs(orig[n]);     
00229         \}
00230     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}{\index{avda@{avda}!max@{max}}
\index{max@{max}!avda@{avda}}
\subsubsection[{max}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Maximum} avda\+::max (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size}
\end{DoxyParamCaption}
)}}\label{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}
Finds the maximum value in an array.


\begin{DoxyParams}{Parameters}
{\em data} & the array whose maximum value is to be found\\
\hline
{\em uint32} & size the number of elements in the data array\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the maximum value and its index in a \hyperlink{structMaximum}{Maximum} structure 
\end{DoxyReturn}


Definition at line \hyperlink{sigmath_8hpp_source_l00232}{232} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00232                                             \{
00233         \hyperlink{structMaximum}{Maximum} m;
00234 
00235         \textcolor{comment}{//loop to run through the length of array data}
00236         \textcolor{keywordflow}{for} (\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00237             \textcolor{comment}{/* }
00238 \textcolor{comment}{             * when value at data[i] is above max.value,}
00239 \textcolor{comment}{             * sets max.value equal to data[i] and max.index equal to i}
00240 \textcolor{comment}{             */}
00241             \textcolor{keywordflow}{if} (data[i] > m.\hyperlink{structMaximum_aa7e84cbf37b694670142670014366969}{value}) \{
00242                 m.\hyperlink{structMaximum_aa7e84cbf37b694670142670014366969}{value} = data[i];
00243                 m.\hyperlink{structMaximum_a2e6aef03795cd285fe542d0861c6e3b5}{index} = i;
00244             \}
00245         \}
00246 
00247         \textcolor{keywordflow}{return} m;
00248     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=330pt]{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_ae20728e7e8ae50bf2f74849e538841ea}{\index{avda@{avda}!Patient\+Name@{Patient\+Name}}
\index{Patient\+Name@{Patient\+Name}!avda@{avda}}
\subsubsection[{Patient\+Name}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string avda\+::\+Patient\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{namespaceavda_ae20728e7e8ae50bf2f74849e538841ea}
Prompts a user to enter a first, middle, and last name for a patients and creates a file (if necessary) in which all of a patient's data can be saved. A newly created file will contain the C\+S\+V header for the file's data.

Must warn a user if the patient folder does not already exist in order to prevent missaving data.

\begin{DoxyReturn}{Returns}
the file under which all patient data is saved 
\end{DoxyReturn}


Definition at line \hyperlink{fileio_8hpp_source_l00043}{43} of file \hyperlink{fileio_8hpp_source}{fileio.\+hpp}.


\begin{DoxyCode}
00043                             \{
00044         std::string fname = \textcolor{stringliteral}{""};
00045         std::string mname = \textcolor{stringliteral}{""};
00046         std::string lname = \textcolor{stringliteral}{""};
00047         std::string patfil = \textcolor{stringliteral}{""};
00048         std::string patientname = \textcolor{stringliteral}{""};
00049         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} track1 = 0;
00050         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} track2 = 0;
00051         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} track3 = 0;
00052 
00053         \textcolor{keywordflow}{do} \{
00054             std::cout << \textcolor{stringliteral}{"Please enter the patients name."} << std::endl;
00055             std::cout << \textcolor{stringliteral}{"First name: "};
00056             std::cin >> fname;
00057             std::cout << \textcolor{stringliteral}{"Middle name: "};
00058             std::cin >> mname;
00059             std::cout << \textcolor{stringliteral}{"Last name: "};
00060             std::cin >> lname;
00061 
00062             \textcolor{comment}{// creates new std::string with path to patient file}
00063             patientname = \hyperlink{namespaceavda_a8ee73ec0cb55d4a13e89949764dce89d}{PATIENT\_PATH} + lname + \textcolor{stringliteral}{", "} + fname
00064                 + \textcolor{stringliteral}{" "} + mname + \textcolor{stringliteral}{".csv"};
00065 
00066             \textcolor{comment}{// prints out patientname. shows user the path to the patient file}
00067             \textcolor{comment}{//std::cout << patientname << std::endl << std::endl;}
00068             std::ifstream file(patientname.c\_str());
00069 
00070             \textcolor{keywordflow}{if} (file.good()) \{
00071                 track1 = 1;
00072             \}
00073 
00074             \textcolor{comment}{/*}
00075 \textcolor{comment}{             * Compares patientname to existing files and lets user know}
00076 \textcolor{comment}{             * if the file does not exist.}
00077 \textcolor{comment}{             */}
00078             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!file.good()) \{
00079                 \textcolor{comment}{/* }
00080 \textcolor{comment}{                 * Do while statement to continue asking user about the file}
00081 \textcolor{comment}{                 * if their input is not acceptable}
00082 \textcolor{comment}{                 */} 
00083                 \textcolor{keywordflow}{do} \{
00084                     std::cout << \textcolor{stringliteral}{"Patient file does not exist, would you like "}
00085                         \textcolor{stringliteral}{"to create file or re-enter their name?"} << std::endl;
00086                     std::cout << \textcolor{stringliteral}{"  *Type 'create' and press enter key "}
00087                         \textcolor{stringliteral}{"to create the patient file."} << std::endl;
00088                     std::cout << \textcolor{stringliteral}{"  *Type 'reenter' and press enter key "}
00089                         \textcolor{stringliteral}{"to re-enter the patients name."} << std::endl;
00090                     std::cout << std::endl;
00091                     std::cin >> patfil;
00092 
00093                     \textcolor{comment}{/* }
00094 \textcolor{comment}{                     * patfil equals create, track1 and 2 will increase}
00095 \textcolor{comment}{                     * escaping both do while loops}
00096 \textcolor{comment}{                     */}
00097                     \textcolor{keywordflow}{if}(patfil == \textcolor{stringliteral}{"create"}) \{
00098                         std::ofstream createfile(patientname.c\_str());
00099                         track1 = 1;
00100                         track2 = 1;
00101                         track3 = 1;
00102                         createfile << \hyperlink{namespaceavda_ac568a0872c2c176d874b8b12f67f43ea}{CSV\_HEADER} << std::endl;
00103                         createfile.flush();
00104                         createfile.close();
00105                     \}
00106 
00107                     \textcolor{comment}{/*}
00108 \textcolor{comment}{                     *patfil equals renter, track1 will remain zero allowing}
00109 \textcolor{comment}{                     *user to reenter the patient name.}
00110 \textcolor{comment}{                     */}
00111                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(patfil == \textcolor{stringliteral}{"reenter"}) \{
00112                         track1 = 0;
00113                         track2 = 1;
00114                     \}
00115 
00116                     \textcolor{comment}{/*}
00117 \textcolor{comment}{                     *The users input was neither create or reenter. User}
00118 \textcolor{comment}{                     *must enter patient name again.}
00119 \textcolor{comment}{                     */}
00120                     \textcolor{keywordflow}{else} \{
00121                         std::cout << std::endl;
00122                         std::cout << \textcolor{stringliteral}{"Your input is not acceptable."} << std::endl;
00123                         std::cout << std::endl;
00124                     \}
00125                 \}\textcolor{keywordflow}{while}(track2 == 0);
00126             \}
00127         \} \textcolor{keywordflow}{while} (track1 == 0);
00128 
00129         \textcolor{keywordflow}{return} patientname; \textcolor{comment}{//returns the path to the patient file}
00130     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{namespaceavda_ae20728e7e8ae50bf2f74849e538841ea_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a34f661f9a357bb68b0aa3662cc821e4d}{\index{avda@{avda}!play@{play}}
\index{play@{play}!avda@{avda}}
\subsubsection[{play}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::play (
\begin{DoxyParamCaption}
\item[{auto}]{filename}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a34f661f9a357bb68b0aa3662cc821e4d}
Plays a W\+A\+V\+E file in a loop in a non-\/blocking manner.


\begin{DoxyParams}{Parameters}
{\em filename} & the absolute or relative path to the W\+A\+V\+E file \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sound_8hpp_source_l00020}{20} of file \hyperlink{sound_8hpp_source}{sound.\+hpp}.


\begin{DoxyCode}
00020                              \{
00021 
00022     \}
\end{DoxyCode}
\hypertarget{namespaceavda_a5196cce27286d08ca144a460caee7839}{\index{avda@{avda}!process@{process}}
\index{process@{process}!avda@{avda}}
\subsubsection[{process}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Data\+Params} avda\+::process (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size, }
\item[{{\bf float32}}]{sampling\+Rate}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a5196cce27286d08ca144a460caee7839}
Analyzes a single recording to determine the drop-\/off frequency and average noiseband noise power.

It should be noted that is algorithm is considered the intellectual property of Andrew Wisner and Nicholas Nolan. The \char`\"{}algorithm\char`\"{} is defined as the use of 1) the frequency drop-\/off and/or 2) a noise value from the frequency band above the drop-\/off frequency in order to diagnose (with or without other factors and parameters) the presence of a avdaspasm in a patient. By faculty members and/or students in the U\+A\+B E\+C\+E department using this algorithm, they agree that the presentation of their code or project that uses this algorithm by anyone directly or indirectly related to the code or project, whether verbally or in writing, will reference the development of the initial algorithm by Andrew Wisner and Nicholas Nolan. Furthermore, a failure to meet this stipulation will warrant appropriate action by Andrew Wisner and/or Nicholas Nolan. It should be understood that the purpose of this stipulation is not to protect prioprietary rights; rather, it is to help ensure that the intellectual property of the aforementioned is protected and is neither misrepresented nor claimed implicitly or explicitly by another individual.


\begin{DoxyParams}{Parameters}
{\em data} & array containing float32 samples of audio\\
\hline
{\em size} & number of samples in each recording. M\+U\+S\+T be a power of two.\\
\hline
{\em sampling\+Rate} & the sampling frequency in Hz or Samples/second\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
cut-\/off frequency (Hz) and average noiseband noise power in decibels 
\end{DoxyReturn}


Definition at line \hyperlink{process_8hpp_source_l00048}{48} of file \hyperlink{process_8hpp_source}{process.\+hpp}.


\begin{DoxyCode}
00048                                                                          \{
00049         \textcolor{keywordflow}{if}((size & (size - 1) != 0) || size < 2) \{
00050             \textcolor{keywordflow}{throw} std::invalid\_argument(
00051                     \textcolor{stringliteral}{"The number of samples is not a power of two!"});
00052         \}
00053 
00054         \textcolor{comment}{// declare function-scoped variables}
00055         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} freqSize = size / 2;
00056         \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}* cdata = (\hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}*)std::malloc(size * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_a960be6b6614c08090c16574dba10a421}{cfloat32}));
00057         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}* fdata = (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}*)std::malloc(freqSize * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}));
00058         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}* origdata = (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}*)std::malloc(freqSize * \textcolor{keyword}{sizeof}(
      \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32}));
00059 
00060         \textcolor{comment}{// convert data to complex numbers for fft()}
00061         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00062             cdata[i] = data[i];
00063         \}
00064     
00065         \textcolor{comment}{// find frequency spectrum in relative decibels}
00066         \hyperlink{namespaceavda_a33a1102422421212ac6b9387c896e864}{fft}(cdata, size);
00067         \hyperlink{namespaceavda_a213bd6384fc9a330e4db2cecdbcd73ee}{mag}(cdata, fdata, freqSize);
00068         \hyperlink{structMaximum}{Maximum} maximum = \hyperlink{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}{max}(fdata, freqSize);
00069 
00070         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < freqSize; i++) \{
00071             fdata[i] /= maximum.\hyperlink{structMaximum_aa7e84cbf37b694670142670014366969}{value};
00072         \}
00073 
00074         \hyperlink{namespaceavda_a9c0b7f832eace3cbc9c5dddea2ecc9d5}{decibels}(fdata, freqSize);
00075 
00076         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < freqSize; i++) \{
00077             origdata[i] = fdata[i];
00078         \}
00079 
00080         \textcolor{comment}{/*}
00081 \textcolor{comment}{         * Run spectrum values through moving-average filter to smooth the}
00082 \textcolor{comment}{         * curve and make it easier to determine the derivative.}
00083 \textcolor{comment}{         */}
00084         \hyperlink{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}{smooth}(fdata, freqSize, 20);
00085 
00086         \textcolor{comment}{/*}
00087 \textcolor{comment}{         * Find the derivative of the smoothed spectrum. Bote that both this}
00088 \textcolor{comment}{         * filter and the previous are necessary to the algorithm.}
00089 \textcolor{comment}{         */}
00090         \hyperlink{namespaceavda_a3e9b92cfa9d76c4c363e8ed8a4c1a2ce}{diff}(fdata, freqSize);
00091         \hyperlink{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}{smooth}(fdata, freqSize, 100);
00092         \hyperlink{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}{absolute}(fdata, freqSize);
00093 
00094         \textcolor{comment}{// find the parameters of this specific recording}
00095         \hyperlink{definitions_8hpp_a05f6b0ae8f6a6e135b0e290c25fe0e4e}{uint16} offset = 1000;
00096         \hyperlink{namespaceavda_aa771d0ed99fc4954c643ea71e91905bf}{absolute}(&fdata[offset], freqSize - offset);
00097         maximum = \hyperlink{namespaceavda_aa82021c3ee552773c060b1a39caf8aaa}{max}(&fdata[offset], freqSize - offset);
00098         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} index = maximum.\hyperlink{structMaximum_a2e6aef03795cd285fe542d0861c6e3b5}{index} + offset;
00099         
00100         \hyperlink{structDataParams}{DataParams} params;
00101         params.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} = index * (float)\hyperlink{definitions_8hpp_a8ace559345ecba7978591ac2ef22aea4}{SAMPLE\_FREQ} / freqSize / 2;
00102         params.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} = \hyperlink{namespaceavda_a2a830f24a59aa2538ea82f6e000cce61}{average}(&origdata[index + offset],
00103                 freqSize - offset - index);
00104 
00105         free(cdata);
00106         free(fdata);
00107 
00108         \textcolor{keywordflow}{return} params;
00109 
00110     \}
\end{DoxyCode}


Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=274pt]{namespaceavda_a5196cce27286d08ca144a460caee7839_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=232pt]{namespaceavda_a5196cce27286d08ca144a460caee7839_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a46dc980b65ddfc24749ce25c1290e158}{\index{avda@{avda}!Read\+Params@{Read\+Params}}
\index{Read\+Params@{Read\+Params}!avda@{avda}}
\subsubsection[{Read\+Params}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf Side}, {\bf Data\+Params}$>$ avda\+::\+Read\+Params (
\begin{DoxyParamCaption}
\item[{auto}]{filename}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a46dc980b65ddfc24749ce25c1290e158}
Reads the previously computated parameters found in the specified file.


\begin{DoxyParams}{Parameters}
{\em filename} & the absolute or relative path to the file containing the patient data to read\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the patient parameters read for each side 
\end{DoxyReturn}


Definition at line \hyperlink{fileio_8hpp_source_l00141}{141} of file \hyperlink{fileio_8hpp_source}{fileio.\+hpp}.


\begin{DoxyCode}
00141                                                        \{
00142         std::map<Side, DataParams> myMap;
00143         \hyperlink{structDataParams}{DataParams} leftparams;
00144         \hyperlink{structDataParams}{DataParams} rightparams;
00145 
00146         std::ifstream file(filename.c\_str());
00147         std::string leftline;
00148         std::string rightline;
00149         std::string leftsearch = \textcolor{stringliteral}{"Left"};
00150         std::string rightsearch = \textcolor{stringliteral}{"Right"};
00151         std::string paramstring;
00152         std::string lfreqstr;
00153         std::string lnoisestr;
00154         std::string rfreqstr;
00155         std::string rnoisestr;
00156         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} lcnt = 0;
00157         \hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} rcnt = 0;
00158         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} lfreqval;
00159         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} lnoiseval;
00160         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} rfreqval;
00161         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} rnoiseval;
00162 
00163         \textcolor{comment}{/*}
00164 \textcolor{comment}{         * if statement which uses ifstream function to open patient file }
00165 \textcolor{comment}{         * filename)}
00166 \textcolor{comment}{         */}
00167         \textcolor{keywordflow}{if}(file.is\_open()) \{
00168             \textcolor{comment}{/*}
00169 \textcolor{comment}{             * While statement to find the first Left line and save to }
00170 \textcolor{comment}{             *leftline as string.}
00171 \textcolor{comment}{             */}
00172             \textcolor{keywordflow}{while} (getline(file, leftline)) \{
00173                 \textcolor{keywordflow}{if}(leftline.find(leftsearch, 0) != std::string::npos) \{
00174                     \textcolor{keywordflow}{break};
00175                 \}
00176 
00177             \}
00178 
00179             \textcolor{comment}{/*}
00180 \textcolor{comment}{             * While statement to find first right line and save to rightline}
00181 \textcolor{comment}{             * as string.}
00182 \textcolor{comment}{             */}
00183             \textcolor{keywordflow}{while} (getline(file,rightline)) \{
00184                 \textcolor{keywordflow}{if}(rightline.find(rightsearch, 0) != std::string::npos) \{
00185                     \textcolor{keywordflow}{break};
00186                 \}
00187             \}
00188 
00189             \textcolor{comment}{// Code to break leftline and rightline into its parts}
00190             std::stringstream lss(leftline);
00191             std::stringstream rss(rightline);
00192 
00193             \textcolor{keywordflow}{while}(getline(lss,paramstring, \textcolor{charliteral}{','})) \{
00194                 lcnt++;
00195 
00196                 \textcolor{keywordflow}{if}(lcnt == 3) \{
00197                     lfreqstr = paramstring;
00198                 \}
00199 
00200                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(lcnt == 4) \{
00201                     lnoisestr = paramstring;
00202                 \}
00203             \}
00204 
00205             \textcolor{keywordflow}{while}(getline(rss,paramstring, \textcolor{charliteral}{','})) \{
00206                 rcnt++;
00207 
00208                 \textcolor{keywordflow}{if}(rcnt == 3) \{
00209                     rfreqstr = paramstring;
00210                 \}
00211 
00212                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(rcnt == 4) \{
00213                     rnoisestr = paramstring;
00214                 \}
00215             \}
00216 
00217             \textcolor{comment}{/*}
00218 \textcolor{comment}{             * Statement to convert lfreq, lnoise, rfreq, and rnoise from}
00219 \textcolor{comment}{             * strings to floats.}
00220 \textcolor{comment}{             * */}
00221             lfreqval = atof(lfreqstr.c\_str());
00222             lnoiseval = atof(lnoisestr.c\_str());
00223             rfreqval = atof(rfreqstr.c\_str());
00224             rnoiseval = atof(rnoisestr.c\_str());
00225 
00226             file.close();
00227         \}
00228 
00229         \textcolor{keywordflow}{else} \{
00230             \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"The patient file could not be opened."});
00231         \}
00232 
00233         leftparams.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} = lfreqval;
00234         leftparams.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} = lnoiseval;
00235         rightparams.\hyperlink{structDataParams_a12566e017407647bc8287d62554ad3fb}{freq} = rfreqval;
00236         rightparams.\hyperlink{structDataParams_a4efd1d2231c6fa7c878c9d5e1650738f}{noise} = rnoiseval;
00237 
00238         myMap[Side::Left] = leftparams;
00239         myMap[Side::Right] = rightparams;
00240 
00241         \textcolor{keywordflow}{return} myMap;
00242     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{namespaceavda_a46dc980b65ddfc24749ce25c1290e158_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}{\index{avda@{avda}!smooth@{smooth}}
\index{smooth@{smooth}!avda@{avda}}
\subsubsection[{smooth}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::smooth (
\begin{DoxyParamCaption}
\item[{{\bf float32} $\ast$}]{data, }
\item[{{\bf uint32}}]{size, }
\item[{{\bf uint16}}]{order}
\end{DoxyParamCaption}
)}}\label{namespaceavda_a22583ba7f11b69c955b13155bf9a739d}
Applies an nth-\/order moving-\/average filter to a discrete signal.


\begin{DoxyParams}{Parameters}
{\em data} & the array containing the signal to which the filter should be applied\\
\hline
{\em size} & the number of elements in the data array\\
\hline
{\em order} & the order of the filter \\
\hline
\end{DoxyParams}


Definition at line \hyperlink{sigmath_8hpp_source_l00250}{250} of file \hyperlink{sigmath_8hpp_source}{sigmath.\+hpp}.


\begin{DoxyCode}
00250                                                           \{
00251         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} coeff = 1 / (\hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32})order;
00252         \hyperlink{definitions_8hpp_aacdc525d6f7bddb3ae95d5c311bd06a1}{float32} temp[size];
00253 
00254         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00255             temp[i] = 0;
00256 
00257             \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a05f6b0ae8f6a6e135b0e290c25fe0e4e}{uint16} j = 0; j < order && j <= i; j++) \{
00258                 temp[i] += data[i - j];
00259             \}
00260 
00261             temp[i] *= coeff;
00262         \}
00263 
00264         \textcolor{keywordflow}{for}(\hyperlink{definitions_8hpp_a1134b580f8da4de94ca6b1de4d37975e}{uint32} i = 0; i < size; i++) \{
00265             data[i] = temp[i];
00266         \}
00267     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{namespaceavda_a22583ba7f11b69c955b13155bf9a739d_icgraph}
\end{center}
\end{figure}


\hypertarget{namespaceavda_aba04a08b41833ced32ec803d55a63bee}{\index{avda@{avda}!Write\+Params@{Write\+Params}}
\index{Write\+Params@{Write\+Params}!avda@{avda}}
\subsubsection[{Write\+Params}]{\setlength{\rightskip}{0pt plus 5cm}void avda\+::\+Write\+Params (
\begin{DoxyParamCaption}
\item[{std\+::map$<$ Side, {\bf Data\+Params} $>$}]{my\+Map, }
\item[{auto}]{filename}
\end{DoxyParamCaption}
)}}\label{namespaceavda_aba04a08b41833ced32ec803d55a63bee}
Writes (appends) the passed parameters to the specified file.


\begin{DoxyParams}{Parameters}
{\em my\+Map} & contains the parameters to be written\\
\hline
\end{DoxyParams}
the patient C\+S\+V file's filename 

Definition at line \hyperlink{fileio_8hpp_source_l00251}{251} of file \hyperlink{fileio_8hpp_source}{fileio.\+hpp}.


\begin{DoxyCode}
00251                                                                     \{
00252         \textcolor{keywordtype}{char} temp[80];
00253         std::ofstream file(filename.c\_str(),
00254                 std::ofstream::out | std::ofstream::app);
00255 
00256         \textcolor{comment}{//Gives pointer measurementtime a data type of time\_t.}
00257         time\_t measurementtime;
00258         time(&measurementtime); \textcolor{comment}{//Gets the current time.}
00259         strftime(temp, 80, \textcolor{stringliteral}{"%c"}, localtime(&measurementtime));
00260         std::string fTime = std::string(temp);
00261 
00262         \textcolor{comment}{//if statement to print the Left side parameters to the patient file.}
00263         \textcolor{keywordflow}{if}(file.is\_open()) \{
00264             file << fTime + \textcolor{stringliteral}{","} + \textcolor{stringliteral}{"Left"} + \textcolor{stringliteral}{","}
00265                 + std::to\_string(myMap[Side::Left].freq) 
00266                 + \textcolor{stringliteral}{", "} + std::to\_string(myMap[Side::Left].noise) << std::endl;
00267         \}
00268 
00269         \textcolor{comment}{//if statement to print the Right side parameters to the patient file.}
00270         \textcolor{keywordflow}{if}(file.is\_open()) \{
00271             file << fTime + \textcolor{stringliteral}{","} + \textcolor{stringliteral}{"Right"} + \textcolor{stringliteral}{","}
00272                 + std::to\_string(myMap[Side::Right].freq) 
00273                 + \textcolor{stringliteral}{", "} + std::to\_string(myMap[Side::Right].noise) << std::endl;
00274         \}
00275 
00276         \textcolor{keywordflow}{else} \{
00277             std::cout << \textcolor{stringliteral}{"Patient file can not be opened!"} << std::endl;
00278         \}
00279 
00280         file.close();
00281     \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=255pt]{namespaceavda_aba04a08b41833ced32ec803d55a63bee_icgraph}
\end{center}
\end{figure}




\subsection{Variable Documentation}
\hypertarget{namespaceavda_ac568a0872c2c176d874b8b12f67f43ea}{\index{avda@{avda}!C\+S\+V\+\_\+\+H\+E\+A\+D\+E\+R@{C\+S\+V\+\_\+\+H\+E\+A\+D\+E\+R}}
\index{C\+S\+V\+\_\+\+H\+E\+A\+D\+E\+R@{C\+S\+V\+\_\+\+H\+E\+A\+D\+E\+R}!avda@{avda}}
\subsubsection[{C\+S\+V\+\_\+\+H\+E\+A\+D\+E\+R}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string avda\+::\+C\+S\+V\+\_\+\+H\+E\+A\+D\+E\+R = \char`\"{}Time,{\bf Side},Frequency,Noise Level\char`\"{}}}\label{namespaceavda_ac568a0872c2c176d874b8b12f67f43ea}
First line of C\+S\+V data file, which declares columns. 

Definition at line \hyperlink{fileio_8hpp_source_l00025}{25} of file \hyperlink{fileio_8hpp_source}{fileio.\+hpp}.

\hypertarget{namespaceavda_a8ee73ec0cb55d4a13e89949764dce89d}{\index{avda@{avda}!P\+A\+T\+I\+E\+N\+T\+\_\+\+P\+A\+T\+H@{P\+A\+T\+I\+E\+N\+T\+\_\+\+P\+A\+T\+H}}
\index{P\+A\+T\+I\+E\+N\+T\+\_\+\+P\+A\+T\+H@{P\+A\+T\+I\+E\+N\+T\+\_\+\+P\+A\+T\+H}!avda@{avda}}
\subsubsection[{P\+A\+T\+I\+E\+N\+T\+\_\+\+P\+A\+T\+H}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string avda\+::\+P\+A\+T\+I\+E\+N\+T\+\_\+\+P\+A\+T\+H = \char`\"{}/home/pi/patients/\char`\"{}}}\label{namespaceavda_a8ee73ec0cb55d4a13e89949764dce89d}
Absolute path to the folder containing the patients' data 

Definition at line \hyperlink{fileio_8hpp_source_l00030}{30} of file \hyperlink{fileio_8hpp_source}{fileio.\+hpp}.

